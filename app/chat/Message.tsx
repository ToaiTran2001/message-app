import {
  View,
  Text,
  Animated,
  Easing,
  TextInput,
  TouchableOpacity,
  SafeAreaView,
  Platform,
  FlatList,
  InputAccessoryView,
  Alert,
} from "react-native";
import React, { useEffect, useLayoutEffect, useRef, useState } from "react";
import Thumbnail from "@/components/Thumbnail";
import Icon from "react-native-vector-icons/Ionicons";
import useGlobal from "@/core/global";
import { useSearchParams } from "expo-router/build/hooks";
import { io, Socket } from "socket.io-client";
import { UserInformation } from "@/interfaces/User";

function MessageHeader({ friend }: any) {
  return (
    <View className="flex-row items-center">
      <Thumbnail url={""} size={30} />
      <Text className="font-bold text-dark-100 ml-2 text-lg">
        {friend.name}
      </Text>
    </View>
  );
}

function MessageBubbleMe({ text }: any) {
  return (
    <View className="flex-row p-2 pr-3">
      <View style={{ flex: 1 }} />
      <View
        style={{
          backgroundColor: "#303040",
          borderRadius: 21,
          maxWidth: "75%",
          paddingHorizontal: 16,
          paddingVertical: 12,
          justifyContent: "center",
          marginRight: 8,
          minHeight: 42,
        }}
      >
        <Text
          style={{
            color: "white",
            fontSize: 16,
            lineHeight: 18,
          }}
        >
          {text}
        </Text>
      </View>
    </View>
  );
}

function MessageTypingAnimation({ offset }: any) {
  const y = useRef(new Animated.Value(0)).current;

  useEffect(() => {
    const total = 1000;
    const bump = 200;

    const animation = Animated.loop(
      Animated.sequence([
        Animated.delay(bump * offset),
        Animated.timing(y, {
          toValue: 1,
          duration: bump,
          easing: Easing.linear,
          useNativeDriver: true,
        }),
        Animated.timing(y, {
          toValue: 0,
          duration: bump,
          easing: Easing.linear,
          useNativeDriver: true,
        }),
        Animated.delay(total - bump * 2 - bump * offset),
      ])
    );
    animation.start();
    return () => {
      animation.stop();
    };
  }, []);

  const translateY = y.interpolate({
    inputRange: [0, 1],
    outputRange: [0, -8],
  });

  return (
    <Animated.View
      style={{
        width: 8,
        height: 8,
        marginHorizontal: 1.5,
        borderRadius: 4,
        backgroundColor: "#606060",
        transform: [{ translateY }],
      }}
    />
  );
}

function MessageBubbleFriend({ text = "", friend, typing = false }: any) {
  return (
    <View
      style={{
        flexDirection: "row",
        padding: 4,
        paddingLeft: 16,
      }}
    >
      <Thumbnail url={""} size={42} />
      <View
        style={{
          backgroundColor: "#d0d2db",
          borderRadius: 21,
          maxWidth: "75%",
          paddingHorizontal: 16,
          paddingVertical: 12,
          justifyContent: "center",
          marginLeft: 8,
          minHeight: 42,
        }}
      >
        {typing ? (
          <View style={{ flexDirection: "row" }}>
            <MessageTypingAnimation offset={0} />
            <MessageTypingAnimation offset={1} />
            <MessageTypingAnimation offset={2} />
          </View>
        ) : (
          <Text
            style={{
              color: "#202020",
              fontSize: 16,
              lineHeight: 18,
            }}
          >
            {text}
          </Text>
        )}
      </View>
      <View style={{ flex: 1 }} />
    </View>
  );
}

function MessageBubble({ index, message, friend }: any) {
  const [showTyping, setShowTyping] = useState(false);

  // const messagesTyping = useGlobal(state => state.messagesTyping)
  const messagesTyping = null; // Placeholder for the actual state

  useEffect(() => {
    if (index !== 0) return;
    if (messagesTyping === null) {
      setShowTyping(false);
      return;
    }
    setShowTyping(true);
    const check = setInterval(() => {
      const now = new Date();
      const ms = 9999; // Placeholder for the actual time difference calculation
      if (ms > 10000) {
        setShowTyping(false);
      }
    }, 1000);
    return () => clearInterval(check);
  }, [messagesTyping]);

  if (index === 0) {
    if (showTyping) {
      return <MessageBubbleFriend friend={friend} typing={true} />;
    }
    return;
  }

  return message.is_me ? (
    <MessageBubbleMe text={message.text} />
  ) : (
    <MessageBubbleFriend text={message.text} friend={friend} />
  );
}

function MessageInput({ message, setMessage, onSend }: any) {
  return (
    <View
      style={{
        paddingHorizontal: 10,
        paddingBottom: 10,
        backgroundColor: "white",
        flexDirection: "row",
        alignItems: "center",
      }}
    >
      <TextInput
        placeholder="Message..."
        placeholderTextColor="#909090"
        value={message}
        onChangeText={setMessage}
        style={{
          flex: 1,
          paddingHorizontal: 18,
          borderWidth: 1,
          borderRadius: 25,
          borderColor: "#d0d0d0",
          backgroundColor: "white",
          height: 50,
        }}
      />
      <TouchableOpacity onPress={onSend}>
        <Icon
          name="paper-plane"
          size={22}
          color={"#303040"}
          style={{
            marginHorizontal: 12,
          }}
        />
      </TouchableOpacity>
    </View>
  );
}

const ChatRoom = () => {
  const DEFAULT_SERVER_URL = "http://115.78.92.177:8000/";
  const [socket, setSocket] = useState(null);
  const [isConnected, setIsConnected] = useState(false);
  const [isAuthenticated, setIsAuthenticated] = useState(false);
  const [userID, setUserID] = useState(""); // State l∆∞u User ID ng∆∞·ªùi d√πng nh·∫≠p
  const [serverUrlInput, setServerUrlInput] = useState(DEFAULT_SERVER_URL); // State l∆∞u URL server ng∆∞·ªùi d√πng nh·∫≠p
  const [statusText, setStatusText] = useState("Idle"); // State hi·ªÉn th·ªã tr·∫°ng th√°i chi ti·∫øt
  const user = useGlobal((state) => state.user) as UserInformation;
  const tokens = useGlobal((state) => state.tokens) as string;

  const socketRef = useRef(null); // Ref gi·ªØ instance socket

  useEffect(() => {
    // Ch·ªâ kh·ªüi t·∫°o socket m·ªôt l·∫ßn khi component mount
    if (!socketRef.current && serverUrlInput) {
      setStatusText(`Attempting to connect to ${serverUrlInput}...`);
      const newSocket = io(serverUrlInput, {
        transports: ["websocket"],
        // C√°c t√πy ch·ªçn kh√°c n·∫øu c·∫ßn
        // autoConnect: false // T·∫Øt t·ª± ƒë·ªông k·∫øt n·ªëi n·∫øu mu·ªën ki·ªÉm so√°t b·∫±ng n√∫t nh·∫•n
      });

      socketRef.current = newSocket;
      setSocket(newSocket);

      // Handlers tr·∫°ng th√°i k·∫øt n·ªëi c∆° b·∫£n
      newSocket.on("connect", () => {
        console.log("Socket.IO Connected!");
        setIsConnected(true);
        setStatusText(`Connected to ${serverUrlInput}. Waiting for User ID...`);
        // Sau khi k·∫øt n·ªëi, effect th·ª© 2 s·∫Ω x·ª≠ l√Ω x√°c th·ª±c n·∫øu userID ƒë√£ c√≥
      });

      newSocket.on("disconnect", () => {
        console.log("Socket.IO Disconnected.");
        setIsConnected(false);
        setIsAuthenticated(false); // Reset tr·∫°ng th√°i x√°c th·ª±c
        setStatusText("Disconnected");
      });

      newSocket.on("connect_error", (err) => {
        console.error("Socket.IO Connection Error:", err.message);
        setIsConnected(false);
        setIsAuthenticated(false);
        setStatusText(`Connection Error: ${err.message}`);
        Alert.alert("Connection Error", `Failed to connect: ${err.message}`);
      });

      // newSocket.on("personal_message", (data: any) => {
      //   console.log("üì© Personal Message:", data);
      //   setMessagesList(data);
      // });

      // Handler cho ph·∫£n h·ªìi x√°c th·ª±c (n·∫øu server g·ª≠i ph·∫£n h·ªìi)
      // L∆∞u √Ω: server Python b·∫°n cung c·∫•p d√πng socket.call ('authenticate', ..., callback)
      // Ch√∫ng ta s·∫Ω d√πng emit + callback ·ªü useEffect th·ª© 2
      // Tuy nhi√™n, n·∫øu server c√≥ emit s·ª± ki·ªán 'auth_response' ch·∫≥ng h·∫°n, th√¨ s·∫Ω b·∫Øt ·ªü ƒë√¢y.
      // newSocket.on('auth_response', (response) => { ... });
    } else if (
      socketRef.current &&
      serverUrlInput &&
      !socketRef.current.connected &&
      statusText === "Idle"
    ) {
      // N·∫øu socket ƒë√£ c√≥ nh∆∞ng ch∆∞a k·∫øt n·ªëi v√† tr·∫°ng th√°i Idle (ch∆∞a nh·∫•n connect)
      // C√≥ th·ªÉ th√™m logic socketRef.current.connect(); ·ªü ƒë√¢y n·∫øu autoConnect=false
      // V·ªõi autoConnect m·∫∑c ƒë·ªãnh l√† true, socket s·∫Ω t·ª± k·∫øt n·ªëi khi kh·ªüi t·∫°o
    }

    // Cleanup: Ng·∫Øt k·∫øt n·ªëi khi component unmount ho·∫∑c serverUrlInput thay ƒë·ªïi ƒë·ªÉ kh·ªüi t·∫°o l·∫°i socket
    return () => {
      if (socketRef.current) {
        // Ch·ªâ ng·∫Øt k·∫øt n·ªëi n·∫øu serverUrlInput thay ƒë·ªïi ho·∫∑c component unmount
        console.log("Cleaning up socket connection...");
        socketRef.current.disconnect();
        socketRef.current.off("connect");
        socketRef.current.off("disconnect");
        socketRef.current.off("connect_error");
        // socketRef.current = null; // Kh√¥ng set null ·ªü ƒë√¢y n·∫øu serverUrlInput thay ƒë·ªïi
      }
    };
    // Effect ch·∫°y l·∫°i n·∫øu serverUrlInput thay ƒë·ªïi ƒë·ªÉ t·∫°o socket m·ªõi k·∫øt n·ªëi ƒë·∫øn URL m·ªõi
  }, [serverUrlInput]);

  // --- Effect: T·ª± ƒë·ªông X√°c th·ª±c khi k·∫øt n·ªëi th√†nh c√¥ng v√† c√≥ User ID ---
  useEffect(() => {
    // Ki·ªÉm tra: ƒê√£ k·∫øt n·ªëi, c√≥ User ID, socket instance t·ªìn t·∫°i, v√† CH∆ØA ƒë∆∞·ª£c x√°c th·ª±c
    if (isConnected && user.id && socketRef.current && !isAuthenticated) {
      setStatusText(`Authenticating as ${userID}...`);
      console.log(`Attempting to authenticate with userID: ${user.id}`);
      // G·ª≠i s·ª± ki·ªán 'authenticate' v√† ch·ªù ph·∫£n h·ªìi t·ª´ callback
      socketRef.current.emit(
        "authenticate",
        { userID: user.id },
        (response) => {
          console.log("Authentication response:", response);
          if (response && response.status === "success") {
            setIsAuthenticated(true);
            setStatusText(`Authenticated successfully as ${response.user_id}`);
            console.log(`Authenticated successfully as ${response.user_id}`);
          } else {
            setIsAuthenticated(false);
            // Hi·ªÉn th·ªã l·ªói t·ª´ server n·∫øu c√≥
            const errorMessage =
              response && response.message
                ? response.message
                : "Authentication failed";
            setStatusText(`Authentication Failed: ${errorMessage}`);
            console.error("Authentication failed:", errorMessage);
            Alert.alert("Authentication Failed", errorMessage);
            // C√≥ th·ªÉ ng·∫Øt k·∫øt n·ªëi n·∫øu x√°c th·ª±c th·∫•t b·∫°i ƒë·ªÉ tr√°nh v√≤ng l·∫∑p
            // socketRef.current.disconnect();
          }
        }
      );
    } else if (!isConnected) {
      // N·∫øu User ID thay ƒë·ªïi khi ƒëang offline, reset tr·∫°ng th√°i x√°c th·ª±c
      setIsAuthenticated(false);
    }
  }, [isConnected, userID, isAuthenticated]); // Ch·∫°y l·∫°i effect n·∫øu 3 state n√†y thay ƒë·ªïi
  const [message, setMessage] = useState("");

  // const messagesList = useGlobal((state) => state.messagesList);
  // const messagesNext = useGlobal((state) => state.messagesNext);

  // const messageList = useGlobal((state) => state.messageList);
  // const messageSend = useGlobal((state) => state.messageSend);
  // const messageType = useGlobal((state) => state.messageType);
  const [messagesList, setMessagesList] = useState<any[]>([]); // Placeholder for the actual messages list
  // const messagesNext = null; // Placeholder for the actual next messages
  // const messageList = null; // Placeholder for the actual message list function
  // const messageSend = null; // Placeholder for the actual message send function
  // const messageType = null; // Placeholder for the actual message type function

  const connectionId = useSearchParams().get("id");
  const friendString = useSearchParams().get("friend");
  const friend =
    typeof friendString === "string" ? JSON.parse(friendString) : friendString;

  // const connectionId = route.params.id
  // const friend = route.params.friend
  // const friend = null; // Placeholder for the actual friend data
  // const connectionId = null; // Placeholder for the actual connection ID

  /// Update the header
  // useLayoutEffect(() => {
  //   navigation.setOptions({
  //     headerTitle: () => (
  //       <MessageHeader friend={friend} />
  //     )
  //   })
  // }, [])

  // useEffect(() => {
  //   messageList(connectionId);
  // }, []);

  const onSend = () => {
    const cleaned = message.replace(/\s+/g, " ").trim();
    if (cleaned.length === 0) return;
    // messageSend(connectionId, cleaned)
    const respone = socketRef.current?.emit("send_message", {
      receiver: friend?.id,
      type: "personal",
      content: message,
    });
    setMessage("");
  };

  function onType(value: any) {
    setMessage(value);
    // messageType(friend.username)
  }

  // interface PersonalMessageData {
  //   sender: string; // Replace with the actual type, e.g., `string`
  //   content: string; // Replace with the actual type, e.g., `string`
  //   timestamp?: string; // Optional field, replace with the correct type if required
  // }

  // Function to handle personal message
  const setupSocketListeners = (socket: Socket): void => {
    socket.on("personal_message", (data: any) => {
      console.log("üì© Personal Message:", data);
      setMessagesList(data);
    });
  };

  return (
    <SafeAreaView style={{ flex: 1 }}>
      <View
        style={{
          flex: 1,
          marginBottom: Platform.OS === "ios" ? 60 : 0,
        }}
      >
        <FlatList
          automaticallyAdjustKeyboardInsets={true}
          contentContainerStyle={{
            paddingTop: 30,
          }}
          data={[{ id: -1 }, ...messagesList]}
          inverted={true}
          keyExtractor={(item) =>
            typeof item === "string" ? item : item.id.toString()
          }
          onEndReached={() => {
            // if (messagesNext) {
            //   messageList(connectionId, messagesNext)
            // }
          }}
          renderItem={({ item, index }) => (
            <MessageBubble index={index} message={item} friend={friend} />
          )}
        />
      </View>

      {Platform.OS === "ios" ? (
        <InputAccessoryView>
          <MessageInput message={message} setMessage={onType} onSend={onSend} />
        </InputAccessoryView>
      ) : (
        <MessageInput message={message} setMessage={onType} onSend={onSend} />
      )}
    </SafeAreaView>
  );
};

export default ChatRoom;
